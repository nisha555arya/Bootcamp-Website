{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport useLazyRef from '@mui/utils/useLazyRef';\n/**\r\n * Lazy initialization container for the Ripple instance. This improves\r\n * performance by delaying mounting the ripple until it's needed.\r\n */\nexport class LazyRipple {\n  /** React ref to the ripple instance */\n\n  /** If the ripple component should be mounted */\n\n  /** Promise that resolves when the ripple component is mounted */\n\n  /** If the ripple component has been mounted */\n\n  /** React state hook setter */\n\n  static create() {\n    return new LazyRipple();\n  }\n  static use() {\n    /* eslint-disable */\n    const ripple = useLazyRef(LazyRipple.create).current;\n    const [shouldMount, setShouldMount] = React.useState(false);\n    ripple.shouldMount = shouldMount;\n    ripple.setShouldMount = setShouldMount;\n    React.useEffect(ripple.mountEffect, [shouldMount]);\n    /* eslint-enable */\n\n    return ripple;\n  }\n  constructor() {\n    this.ref = {\n      current: null\n    };\n    this.mounted = null;\n    this.didMount = false;\n    this.shouldMount = false;\n    this.setShouldMount = null;\n  }\n  mount() {\n    if (!this.mounted) {\n      this.mounted = createControlledPromise();\n      this.shouldMount = true;\n      this.setShouldMount(this.shouldMount);\n    }\n    return this.mounted;\n  }\n  mountEffect = () => {\n    if (this.shouldMount && !this.didMount) {\n      if (this.ref.current !== null) {\n        this.didMount = true;\n        this.mounted.resolve();\n      }\n    }\n  };\n\n  /* Ripple API */\n\n  start() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    this.mount().then(() => this.ref.current?.start(...args));\n  }\n  stop() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    this.mount().then(() => this.ref.current?.stop(...args));\n  }\n  pulsate() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    this.mount().then(() => this.ref.current?.pulsate(...args));\n  }\n}\nexport default function useLazyRipple() {\n  return LazyRipple.use();\n}\nfunction createControlledPromise() {\n  let resolve;\n  let reject;\n  const p = new Promise((resolveFn, rejectFn) => {\n    resolve = resolveFn;\n    reject = rejectFn;\n  });\n  p.resolve = resolve;\n  p.reject = reject;\n  return p;\n}","map":{"version":3,"names":["React","useLazyRef","LazyRipple","create","use","ripple","current","shouldMount","setShouldMount","useState","useEffect","mountEffect","constructor","ref","mounted","didMount","mount","createControlledPromise","resolve","start","args","then","stop","pulsate","useLazyRipple","reject","p","Promise","resolveFn","rejectFn"],"sources":["D:/React js/techun/node_modules/@mui/material/useLazyRipple/useLazyRipple.js"],"sourcesContent":["'use client';\r\n\r\nimport * as React from 'react';\r\nimport useLazyRef from '@mui/utils/useLazyRef';\r\n/**\r\n * Lazy initialization container for the Ripple instance. This improves\r\n * performance by delaying mounting the ripple until it's needed.\r\n */\r\nexport class LazyRipple {\r\n  /** React ref to the ripple instance */\r\n\r\n  /** If the ripple component should be mounted */\r\n\r\n  /** Promise that resolves when the ripple component is mounted */\r\n\r\n  /** If the ripple component has been mounted */\r\n\r\n  /** React state hook setter */\r\n\r\n  static create() {\r\n    return new LazyRipple();\r\n  }\r\n  static use() {\r\n    /* eslint-disable */\r\n    const ripple = useLazyRef(LazyRipple.create).current;\r\n    const [shouldMount, setShouldMount] = React.useState(false);\r\n    ripple.shouldMount = shouldMount;\r\n    ripple.setShouldMount = setShouldMount;\r\n    React.useEffect(ripple.mountEffect, [shouldMount]);\r\n    /* eslint-enable */\r\n\r\n    return ripple;\r\n  }\r\n  constructor() {\r\n    this.ref = {\r\n      current: null\r\n    };\r\n    this.mounted = null;\r\n    this.didMount = false;\r\n    this.shouldMount = false;\r\n    this.setShouldMount = null;\r\n  }\r\n  mount() {\r\n    if (!this.mounted) {\r\n      this.mounted = createControlledPromise();\r\n      this.shouldMount = true;\r\n      this.setShouldMount(this.shouldMount);\r\n    }\r\n    return this.mounted;\r\n  }\r\n  mountEffect = () => {\r\n    if (this.shouldMount && !this.didMount) {\r\n      if (this.ref.current !== null) {\r\n        this.didMount = true;\r\n        this.mounted.resolve();\r\n      }\r\n    }\r\n  };\r\n\r\n  /* Ripple API */\r\n\r\n  start(...args) {\r\n    this.mount().then(() => this.ref.current?.start(...args));\r\n  }\r\n  stop(...args) {\r\n    this.mount().then(() => this.ref.current?.stop(...args));\r\n  }\r\n  pulsate(...args) {\r\n    this.mount().then(() => this.ref.current?.pulsate(...args));\r\n  }\r\n}\r\nexport default function useLazyRipple() {\r\n  return LazyRipple.use();\r\n}\r\nfunction createControlledPromise() {\r\n  let resolve;\r\n  let reject;\r\n  const p = new Promise((resolveFn, rejectFn) => {\r\n    resolve = resolveFn;\r\n    reject = rejectFn;\r\n  });\r\n  p.resolve = resolve;\r\n  p.reject = reject;\r\n  return p;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}